<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>사용자 정의 함수 - 1</title>
</head>
<body>
    <h2>사용자 정의 함수 - 1</h2>
    <script>
        'use strict';
        console.log('1. 함수 선언식 방식 ----------');
        func1();    // 함수 선언 전에 호출해도 실행 가능
        function func1() {
            console.log('func1() 함수 호출!');
        }
        func1();    // 함수 선언 후에 호출해도 실행 가능

        // 함수 선언 전과 후 모두 호출해도 실행되는 이유?
        // 자바스크립트의 특징이다.

        // Why? 
        // 자바스크립트는 인터프리터로 되어 있는데 이 인터프리터는 한 번만 읽지 않기 때문이다!

        // 인터프리터는 총 두 번 도는데,
        // 제일 처음 스크립트 안에 함수 선언식이 있는지 먼저 쭉 읽고
        // 만약 함수가 있다면 걔네들은 먼저 읽는다.
        // 그리고 두 번째로 돌 때에 명령어 수행한다.

        // [결론] 함수 선언 전에 호출해도 실행가능한 것은 
        // 함수를 먼저 메모리에 올려 놓고 그 다음에 실행문을 읽어가기 때문이다!
        // 그리고 그 방식을 함수 선언식이라고 부른다.

        console.log('2. 함수 표현식 방식 ----------')
        //Hello1(); // 함수 선언 전에 호출 불가능
                    // 에러 : Uncaught ReferenceError: Cannot access 'Hello1' before initialization
        // 익명함수의 주소를 가지고 있는 상수
        // [주의] Hello1 함수 이름 아님 상수임...!
        const Hello1 = function() {
            console.log('Hello1 함수 호출!');
        }
        Hello1();   // 함수 선언 후에 사용 가능

        // ECMA6에서 권장하는 방법?
        // 2. 함수 표현식 방식이다.

        // Why?
        // 2. 함수 표현식 방식은 선언 전에는 사용할 수 없다는 점이 불편해 보이고
        // 1. 함수 선언식 방식이 선언 전에도 에러 없이 쓸 수 있다는 점이 편하게 보일 수는 있다.
        // 하지만 ECMA6에서 2. 함수 표현식 방식을 권장하는 이유는 'use strict';를 쓰는 이유와 동일하다.
        // 문법적으로 말도 안되는 상황이나 헷갈릴 수 있는 상황을 방지하기 위해서 2. 함수 표현식 방식을 권장한다.
    </script>
</body>
</html>